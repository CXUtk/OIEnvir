#include <cstring>
#include <cmath>
#include <cstdio>
#include <vector>
#include <queue>
#include <algorithm>
#include <map>
#include <set>
using namespace std;

typedef long long ll;

const int INF = 2147483647;
const double EPS = 1e-15;
const double PI = 3.1415926;
const int MOD = 998244353;

int dr[4] = {-1, 0, 1, 0};
int dc[4] = {0, 1, 0, -1};
char dir[5] = "NESW";
char turn[5] = "FLR";
char name[25];


struct Node {
	int r, c, d;

};
unsigned char dirTable[11][11][4];
int dis[11][11][4];
Node p[11][11][4];
int N = 9;
int dir_id(int d){
	return strchr(dir, d) - dir;
}
int turn_id(int d){
	return strchr(turn, d) - turn;
}

Node getNext(const Node& n, char d){

	auto i = dir_id(d);
	return {n.r + dr[i], n.c + dc[i], i};
}


Node walk(const Node& n, char turn){
	int d = n.d;
	if(turn == 1)
		d = (d + 3) % 4;
	if(turn == 2)
		d = (d + 1) % 4;
	return {n.r + dr[d], n.c + dc[d], d};
}

bool check(const Node& n){
	return n.r > 0 && n.r <= N && n.c > 0 && n.c <= N;
}

void printAns(const Node& n){
	vector<Node> path;
	path.push_back(n);
	Node nextN = p[n.r][n.c][n.d];
	while(nextN.r != 0){
		path.push_back(nextN);
		nextN = p[nextN.r][nextN.c][nextN.d];
	}
	int c = 0;
	reverse(path.begin(), path.end());
	printf(" ");
	for(auto a : path){
		c++;
		printf(" (%d,%d)", a.r, a.c);
		if(c == 10) {
			printf("\n ");
			c = 0;
		}
	}
	printf("\n");
}

int main() {
	while(scanf("%s", name)){
		if(!strcmp(name, "END"))
			break;
		int rr, cc;
		Node start;
		Node end;
		char dd;
		scanf("%d %d %c %d %d", &rr, &cc, &dd, &end.r, &end.c);
		start.r = rr;
		start.c = cc;
		start = getNext(start, dd);

		int r;
		while(scanf("%d", &r) && r){
			int c;
			char buf[32];
			scanf("%d", &c);
			while(scanf("%s", buf)){
				if(buf[0] == '*')
					break;
				char d = buf[0];
				int len = strlen(buf);
				for(int i = 1; i < len; i++){
					dirTable[r][c][dir_id(d)] |= (1 << turn_id(buf[i]));
				}
			}
		}
		memset(dis, 0x3f, sizeof(dis));
		queue<Node> Q;
		dis[start.r][start.c][start.d] = 0;
		p[start.r][start.c][start.d] = {rr, cc, dd};
		Q.push(start);
		bool found = false;
		if(!check(start)){
			Q.pop();
		}
		while(!Q.empty()){
			auto n = Q.front();
			Q.pop();
			if(n.r == end.r && n.c == end.c){
				// End
				printf("%s\n", name);
				printAns(n);
				found = true;
				break;
			}
			for(int i = 0; i < 3; i++){
				Node nextN = walk(n, i);
				if(((dirTable[n.r][n.c][n.d] >> i) & 1) && check(nextN)
						&& dis[nextN.r][nextN.c][nextN.d] > dis[n.r][n.c][n.d] + 1){

					dis[nextN.r][nextN.c][nextN.d] = dis[n.r][n.c][n.d] + 1;
					p[nextN.r][nextN.c][nextN.d] = n;
					Q.push(nextN);
				}
			}
		}
		if(!found) {
			printf("%s\n", name);
			printf("  No Solution Possible\n");
		}
		memset(p, 0, sizeof(p));
		memset(dirTable, 0, sizeof(dirTable));
	}
	return 0;
}